from google.colab import drive
drive.mount("/content/drive/")

import json
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Load the JSON file
with open('/content/drive/My Drive/Elham/up to date data/received_data_MID_EXP.json', 'r') as file:
    data = json.load(file)

# Initialize an empty list to store processed rows
rows = []
current_label = None

# Process each entry in the JSON data
for entry in data:
    if "message" in entry:
        # Parse the message string as JSON
        message = json.loads(entry["message"])
        row = {
            "mac_address": message["mac_address"],
            "name": message["name"],
            "rssi": message["rssi"],
            "receiver": message["receiver_id"],
            "timestamp": message["timestamp"],
            "label": current_label,
        }
        rows.append(row)
    elif "coordinates" in entry:
        # Update the current label based on coordinates
        coordinates = entry["coordinates"]
        room_number = coordinates["x"]
        for row in rows:
            if row.get("label") is None:
                row["label"] = room_number
        current_label = None

# Convert the list of rows into a Pandas DataFrame
df = pd.DataFrame(rows)

# Step 1: Find unique values in 'label' column
unique_labels = df['label'].unique()

# Step 2: Define a list of colors for the histograms
  # Get a colormap with enough colors

# Step 3: Loop through each unique label
for label in unique_labels:
    # Filter the dataframe by the current label
    label_df = df[df['label'] == label]

    # Find unique 'receiver' values within the filtered label data
    unique_receivers = label_df['receiver'].unique()
    colors = plt.cm.get_cmap('tab10', len(unique_receivers))
    unique_EBCONs = label_df['mac_address'].unique()
    colors2 = plt.cm.get_cmap('tab10', len(unique_EBCONs))

    # Step 4: Plot histogram and line chart for each unique 'receiver' within the current label
    fig, (ax1) = plt.subplots(1, figsize=(15, 6))  # Create subplots: one for histogram, one for line chart

    # Plot histograms
    for idx, receiver in enumerate(unique_receivers):
        receiver_data = label_df[label_df['receiver'] == receiver]
        ax1.hist(receiver_data['rssi'], bins=20, alpha=0.5, label=f'Receiver {receiver}', color=colors(idx))

        fig, (ax2) = plt.subplots(1, figsize=(15, 6))
        for idx, ebcon in enumerate(unique_EBCONs):
            ebcon_data = receiver_data[receiver_data['mac_address'] == ebcon]
            ebcon_data = ebcon_data.sort_values(by="timestamp").reset_index(drop=True)
            ebcon_data['time_diff'] = ebcon_data['timestamp'].diff()
            time_diffs = ebcon_data['time_diff'].dropna()
            min_gap = time_diffs.min()
            max_gap = time_diffs.max()
            # print(f"Minimum gap of {receiver} raspbery for {ebcon} ebcon: {min_gap} seconds")
            # print(f"Maximum gap of {receiver} raspbery for {ebcon} ebcon: {max_gap} seconds")
            ax2.hist(time_diffs, bins=50, alpha=0.5, label=f'ebcon {ebcon}', color=colors2(idx))

        ax2.set_title(f'Distribution of Time Gaps for Label: {label}')
        ax2.set_xlabel('Time Gap (seconds)')
        ax2.set_ylabel('Frequency')
        ax2.legend()

    ax1.set_title(f'RSSI Distribution for Label: {label}')
    ax1.set_xlabel('RSSI')
    ax1.set_ylabel('Frequency')
    ax1.legend()

    # Plot bar chart (average RSSI per receiver)
    # avg_rssi_per_receiver = label_df.groupby('receiver')['rssi'].mean()
    # ax2.bar(avg_rssi_per_receiver.index, avg_rssi_per_receiver.values, color=colors(np.arange(len(avg_rssi_per_receiver))))

    # ax2.set_title(f'Average RSSI per Receiver for Label: {label}')
    # ax2.set_xlabel('Receiver')
    # ax2.set_ylabel('RSSI')

    # Show the plots
    plt.tight_layout()  # To make sure plots don't overlap
    plt.show()

    plt.figure(figsize=(10, 6))

    # Create the Box plot for 'rssi' values grouped by 'receiver'
    label_df.boxplot(column='rssi', by='receiver', patch_artist=True, grid=False)

    # Customize plot
    plt.title(f'Box and Whisker Plot for Label: {label}')
    plt.suptitle('')  # Remove the default title generated by boxplot
    plt.xlabel('Receiver')
    plt.ylabel('RSSI')

    # Show plot
    plt.show()